# Memory-game
## Игра для тренировки памяти

Игра является улучшенной версией программы Memory-game-beta (с использованием библиотеки ncurses). Правила игры немного изменились.

### Обновленные правила игры

В центре экрана изображаем табло из 7 ячеек. Ячейки заполняем числами от 1 до 7 случайным образом, но не показываем пользователю. После нажатия на клавишу "Начать игру" на небольшой интервал времени (около секунды) числа показываются пользователю для запоминания, а затем снова скрываются. Задача пользователя открыть числа так, чтобы последовательность открытия совпадала со значением открываемых чисел. 
- Теперь нельзя нажать на уже открытые ячейки
- Теперь нет курсора, который необходимо было двигать, нажимая на стрелочки "влево" или "вправо"

### Алгоритм решения задачи

Для решения задачи была использована библиотека Qt.
При помощи инструментов библиотеки был организован пользовательский интерфейс. В него входят виджеты для хранения графических элементов, слои компоновки, отступы и кнопки.
Алгоритм решения задачи был взят с предыдущего лабораторного задания (см. репозиторий Memory-game-beta).
 
#### Описание алгоритма:
1.	Создаем вектор пар. Заполняем первые элементы пары числами int от 1 до 7, а вторые – символами типа QString ‘X’.
2.	Перемешиваем его и выводим второй элемент каждой пары на экран.
3.	Ведем счетчик действий игрока – он увеличивается на 1, когда игрок нажимает на ячейку. Если этот счетчик становится равен 7, то засчитывается победа. Если этот счетчик не равен первому элементу ячейки, то засчитывается поражение.
4.	Игрок информируется о победе или поражении и ему предоставляется выбор: перезапустить игру или нет.
5.	Так же игрок может в любой момент перезапустить игру или выйти из нее. Кнопки, отвечающие за это, называются кнопками меню.
Для связи алгоритма и пользовательского интерфейса использовался механизм Qt – сигналы и слоты.

#### Описание структуры:

Структура программы представляет собой пять классов и структуру enum, которая нужна для удобства работы с кнопками. Три класса отражают возможные состояния интерфейса приложения (MainScreen – главное меню, SettingsScreen – меню настроек, GameScreen – игровое окно).  Они определяют расположение виджетов, кнопок и компоновок в каждом окне. У этих трех классов есть класс-родитель BaseScreen, в котором описаны общие поля различных окон приложения. Последний класс MemoryGame управляет логикой программы и является связующим звеном между тремя состояниями интерфейса.

Описание классов:
1.	Класс BaseScreen хранит общую информацию различных окон приложения, а именно:
- centralWidget (нужен для хранения всех виджетов окна), 
- fontName (задает название шрифта, который будет использован для отображения информации), 
- BUTTONS_FONT (задает размер шрифта кнопок), 
- функция SetFont() – применяет шрифт к QLabel. 
- Также в классе есть сигнал, к которому будем привязывать кнопки меню. 
- Так как класс используется только для наследования, то нам не нужно создавать его объекты, а значит, можно переместить конструктор из public поля.
2.	Класс MainScreen нужен для создания графического интерфейса главного меню программы. 
- В конструкторе инициализируем и добавляем в centralWidget различные виджеты и кнопки. Заполняем правила игры из файла “Rules.txt”. Кнопки меню подключаем к унаследованному сигналу MenuButtonClicked(). 
3.	Класс SettingsScreen нужен для графического интерфейса меню настроек программы. 
- В конструкторе инициализируем и добавляем в centralWidget различные виджеты и кнопки. Слайдер подключаем к слоту updateDifficult() и valuesChanged(). Виджет checkbox также подключаем к слоту valuesChanged(). Кнопки меню подключаем к унаследованному сигналу MenuButtonClicked(). Кнопку «Подтвердить» подключаем к лямбда-функции, которая считывает значения с виджетов и отключает кнопку. 
- Метод SyncTheValues() синхронизирует виджеты с текущими значениями. 
- Слот updateDifficult() обновляет отображение времени на запоминание в зависимости с положением виджета QSlider. 
- Слот valuesChanged() проверяет изменились ли настройки и активирует/деактивирует кнопку «Применить». 
4.	Класс GameScreen нужен для графического интерфейса игрового экрана программы. 
- В конструкторе инициализируем и добавляем в centralWidget различные виджеты и кнопки. Кнопки меню подключаем к унаследованному сигналу MenuButtonClicked(). 
- Геттеры GetButtons() и GetMenuButtons() возвращают ссылки на табло игровых элементов и кнопки меню соответственно. 
5.	Класс MemoryGame используется для управления логикой и связи между тремя состояниями интерфейса.
- Конструктор класса принимает указатели на объекты классов GameScreen, MainMenuScreen, SettingsScreen и MainWindow. Добавляет в stackedWidget созданные виджеты каждого экрана и применяет его к объекту класса MainWindow. Так же конструктор соединяет слоты класса с сигналами кнопок окон интерфейса.
- Поле stackedWidget нужно для переключения между экранами приложения.
- Структура ScreenType используется для удобства переключения между экранами
- Items – вектор из п.1 описания алгоритма решения задачи
- Метод FillInVector() соответствует п. 2 описания алгоритма решения задачи
- Метод FillInButtons() заполняет клетки табло числами из вектора и в зависимости от значения rainbowNums раскрашивает/не раскрашивает их в цвета радуги. Отключает взаимодействие с табло и кнопками меню, запускает таймер на время, указанное в настройках, подключает таймер к слоту onTimeout().
- Метод StartGame() устанавливает параметры настроек и включает экран игры
- Слот TableButtonClicked() реагирует на сигнал взаимодействия с кнопкой табло, открывает выбранную клетку и проверяет, победил ли игрок.
- Слот MenuButtonClicked() реагирует на сигналы взаимодействия с кнопками меню, в зависимости от нажатой кнопки, запускает инструкции.
- Слот onTimeout() срабатывает, когда время с момента подключения таймера в методе FillInButtons() прошло. Заполняет клетки табло символами ‘X’, включает взаимодействие с кнопками меню и игровым табло. 
